= Default Ratings
David Watkins <david.watkins@db.com>
v0.1, 2020-08-14
:toc:


== Rating Scheme recap

The table below shows a typical rating scheme, ordered by the `position` database column (ascending,
not shown):

.Example Rating Scheme
|===
|Rating | Code | Notes

|Invest
|`G`
| -

|Maintain
|`A`
| -

|Disinvest
|`R`
| -

|Unknown
|`Z`
| Not user selectable

|Not Applicable
|`X`
| This is a waltz special code which means the `X` is treated as a removal

|===

NOTE: Usage of special character `X` to indicate deletion should probably be examined to see if it is still
      needed. Suspect it no longer serves a required purpose, especially with formal app-fn decomms.


== Challenges

This section outlines some of the challenges we face in implementing a solution for this feature.


* **Constraint Relationship**, how do we tell Waltz that there is a constraining relationship between a
  _measurable rating_ and some other value in Waltz (for example the app's overall _investment rating_) ?

* **Ordering**, other than a position value (used for display positioning), there is no ordering semantics
  within a _rating scheme_.  Therefore, how do we know how values are restricted  (i.e. if
  the constraint is _'Maintain'_ it means we cannot set a rating to _'Invest'_) ?

* **Constraint Modification**, if the constraining value is altered, how does this impact existing
  _measurable ratings_ ?



=== Constraint Relationship
Each apps needs to (optionally) have a maximal rating per _rating-scheme_ / _measurable category_.
This may require a new table.  An alternative may be to reuse assessments and link a
_measurable category_ to a constraining _assessment rating_.  In this case the assessment and category
would need to share a common _rating scheme_ and be specified somewhere.  We assume that if an application
has no constraining value then _measurable ratings_ are free to pick any value.

NOTE: we need to be careful about using the overall investment rating as a constraint since
      we do not have a clean way of referencing it, unlike assessment_definitions.  However moving
      overall rating to become an _assessment_ may be problematic due to it's widespread usage in
      exporters etc.  Possible solutions are discussed in the section: _'Moving overall
      investment status to assessments'_ below.


=== Ordering
Easiest to simply use position for now and say a rating is _'more restrictive'_ if appears later in the list (has
a higher position value).

.Constraints, moving *down* the table is more restrictive, *up* is _less restrictive_
|===
|Constraint Rating | Permissible Measurable Ratings

|Invest
|Invest, Maintain, Disinvest

|Maintain
|Maintain, Disinvest

|Disinvest
|Disinvest
|===

=== Constraint Modification

The constraining value may not be static.  It may be altered by user interaction, or via a periodic
batch job.  When the values are changed we have two fundamental choices:

* **Hard limit**, the new constraining value becomes a _hard_ upper limit for current measurable
  ratings.
** If the new constraint is more restrictive any current _measurable rating_ which breaches that limit will be
   reset to the new limit
** If the new constraint is less restrictive the more restrictive _measurable ratings_   are left as is.

* **Soft limit**, the new constraining value becomes a _soft_ upper limit.  Breaches are flagged but
  not auto corrected.

* **Ratchet limit**, the new constraining value becomes a _hard_ upper limit when editing _measurable ratings_.
  However breaches are **not** auto corrected, but **are** flagged instead.

NOTE: I think the _ratchet limit_ is the most useful of the options presented above.  _Hard limits_ can
      be enforced via the batch loaders.




== Appendices

=== Moving overall investment status to assessments



** Duplicate investment status as an _assessment rating_
** Remove investment status from application and _only_ have it as an _assessment rating_

If we remove investment status from application we will need to rework the exporters (and importers).
This needs prototyping (see below for initial vendor spikes) but does give us a very useful set of
data to include in our exports (e.g. all assessments for an application).

IMPORTANT: moving investment status will impact batch jobs as inserts/updates will fail unless modified.


==== Example exporters using pivot functions

Database vendors have differing ways of supporting pivoting

.postgres example
[source,sql]
----
select a.name, f.*
from application a
inner join (
    select *
    from crosstab('
    select app.id, ad.name, rsi.name
    from application app
    cross join assessment_definition ad
    left join assessment_rating ar on ar.assessment_definition_id = ad.id and app.id = ar.entity_id
    left join rating_scheme_item rsi on ar.rating_id = rsi.id
    where ad.entity_kind = ''APPLICATION''
    order by app.id, ad.name ')
AS assessment_rating(entity_id bigint, c1 varchar, c2 varchar, c3 varchar, c4 varchar)) f on f.entity_id = a.id
----


=== Original ask from Architects

Below is a lightly edited copy of the request, included here as it provides the driving rationale behind
the design options outlined in the main sections above.

==== Invest Status:

* If _App Investment Status_ is `Invest`, Architect can update _Waltz_ function status to `Maintain` or
`Disinvest` as an override.
* If _App Investment Status_ is `Maintain`, Architect can update _Waltz_ function status to
`Disinvest` as an override.
* If _App Investment Status_ is `Disinvest` or `Decom`, Architect cannot override status in _Waltz_.


==== Nightly job


* If previous App Investment Status equals current WALTZ status, then no overrides exist and App Investment status is synced to Waltz.
* If Previous App Investment status is not equal to current WALTZ status, then override exists:
** If updated App Investment status is more restrictive than Waltz, the override is removed and App Investment status is synced to Waltz from now onwards:
** If updated App Investment status is less restrictive than Waltz, the override is kept and App Investment status is NOT synced to Waltz.
( invest does not replace Maintain/Disinvest and Maintain does not replace Disinvest)


